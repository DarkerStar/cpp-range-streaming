/* 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// Proposed range streaming facilities.
// Version: 1.3.0

/* 
 * This C++ header file implements a proposed extension to the C++ standard
 * library that allows for easy and intuitive input and output of ranges,
 * without requiring the use of the algorithms library.
 * 
 * For more details, check https://github.com/DarkerStar/cpp-range-streaming
 * 
 * Version 1.3.0:
 *   * Added back_insert() and front_insert().
 * 
 * Version 1.2.0:
 *   * Added support for preserving formatting from element to element in
 *     input.
 * 
 * Version 1.1.0:
 *   * Added support for preserving formatting from element to element in
 *     output.
 */

#ifndef STD_STREAM_RANGE_
#define STD_STREAM_RANGE_

#include <iosfwd>
#include <iterator> // Needed for iterator_traits
#include <utility>

namespace std {

/* 
 * All of the monkeyworks necessary for range streaming is in this namespace.
 */
namespace stream_range_detail {

template <typename Range>
using RangeIterator = decltype(begin(declval<Range>()));

template <typename Range>
using RangeValueType = typename iterator_traits<RangeIterator<Range>>::value_type;

} // namespace stream_range_detail

/*# Forward declarations for back_insert() ###################################*/

template <typename Range>
class range_back_inserter;

template <typename Range>
auto back_insert(Range& r, stream_range_detail::RangeValueType<Range> t) ->
  range_back_inserter<Range>;

template <typename Range>
auto back_insert(Range& r) -> range_back_inserter<Range>;

template <typename Range>
auto back_insert_n(Range& r, size_t n, stream_range_detail::RangeValueType<Range> t) ->
  range_back_inserter<Range>;

template <typename Range>
auto back_insert_n(Range& r, size_t n) -> range_back_inserter<Range>;

/*# Forward declarations for front_insert() ##################################*/

template <typename Range>
class range_front_inserter;

template <typename Range>
auto front_insert(Range& r, stream_range_detail::RangeValueType<Range> t) ->
  range_front_inserter<Range>;

template <typename Range>
auto front_insert(Range& r) -> range_front_inserter<Range>;

template <typename Range>
auto front_insert_n(Range& r, size_t n, stream_range_detail::RangeValueType<Range> t) ->
  range_front_inserter<Range>;

template <typename Range>
auto front_insert_n(Range& r, size_t n) -> range_front_inserter<Range>;

/*# Forward declarations for insert() ########################################*/

template <typename Range>
class range_inserter;

template <typename Range>
auto insert(Range& r, stream_range_detail::RangeIterator<Range> i, stream_range_detail::RangeValueType<Range> t) ->
  range_inserter<Range>;

template <typename Range>
auto insert(Range& r, stream_range_detail::RangeIterator<Range> i) -> range_inserter<Range>;

template <typename Range>
auto insert_n(Range& r, stream_range_detail::RangeIterator<Range> i, size_t n, stream_range_detail::RangeValueType<Range> t) ->
  range_inserter<Range>;

template <typename Range>
auto insert_n(Range& r, stream_range_detail::RangeIterator<Range> i, size_t n) -> range_inserter<Range>;

/* 
 * All of the monkeyworks necessary for range streaming is in this namespace.
 */
namespace stream_range_detail {

/* 
 * This is a VERY basic version of the proposed std::range<Iterator> and the
 * associated std::make_range() function. But it does the job here, and using
 * this simple helper class makes the range streaming stuff independent of the
 * rest of the standard library.
 */
template <typename Iterator>
struct iterator_range
{
  auto begin() const -> Iterator { return begin_; }
  auto end()   const -> Iterator { return end_; }
  
  Iterator begin_;
  Iterator end_;
};

template <typename Iterator>
auto make_iterator_range(Iterator b, Iterator e) -> iterator_range<Iterator>
{
  return { b, e };
}

/* 
 * This class stores the formatting state of an ostream object on construction,
 * and can restore that state at any time. It is used to keep consistent
 * formatting for each item.
 */
template <typename CharT, typename Traits>
struct stream_formatting_saver
{
  explicit stream_formatting_saver(basic_ios<CharT, Traits>& s) :
    stream_{s},
    flags_{s.flags()},
    width_{s.width()},
    precision_{s.precision()},
    fill_{s.fill()}
  {}
  
  void restore() const
  {
    stream_.flags(flags_);
    stream_.fill(fill_);
    stream_.precision(precision_);
    stream_.width(width_);
  }
  
  basic_ios<CharT, Traits>& stream_;
  typename basic_ios<CharT, Traits>::fmtflags const flags_;
  streamsize const width_;
  streamsize const precision_;
  CharT const fill_;
};

/* 
 * This is the proxy object returned from the versions of the range streaming
 * functions that don't use delimiters.
 */
template <typename Range>
struct stream_range_proxy
{
  Range range;
};

/* 
 * This is the proxy object returned from the versions of the range streaming
 * functions that use delimiters. Note that the delimiter can be any type that
 * has an insertion operator defined - not just strings.
 */
template <typename Range, typename Delim>
struct stream_range_delimited_proxy
{
  Range range;
  Delim delim;
};

/* 
 * This is the extraction operator for range streaming.
 */
template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, stream_range_proxy<Range> p) ->
  basic_istream<CharT, Traits>&
{
  if (!in)
    return in;
  
  auto const formatting = stream_formatting_saver<CharT, Traits>{in};
  
  for (auto& i : p.range)
  {
    formatting.restore();
    
    if (!(in >> i))
      break;
  }
  
  return in;
}

/* 
 * This is the insertion operator for range streaming without a delimiter.
 */
template <typename CharT, typename Traits, typename Range>
auto operator<<(basic_ostream<CharT, Traits>& out, stream_range_proxy<Range> const& p) ->
  basic_ostream<CharT, Traits>&
{
  if (!out)
    return out;
  
  auto const formatting = stream_formatting_saver<CharT, Traits>{out};
  
  for (auto const& i : p.range)
  {
    formatting.restore();
    
    if (!(out << i))
      break;
  }
  
  return out;
}

/* 
 * This is the insertion operator for range streaming with a delimiter.
 * 
 * Note that it is possible to simplify this somewhat with a slightly different
 * algorithm. First you get the begin and end iterators from the range, and
 * if (begin != end) { out << *begin++; }, then while (begin != end)
 * { out << delim << *begin++; }, with all the requisite checking of the stream
 * state, of course. I thought the version below would be clearer in its intent
 * for the purpose of this demonstration.
 */
template <typename CharT, typename Traits, typename Range, typename Delim>
auto operator<<(basic_ostream<CharT, Traits>& out, stream_range_delimited_proxy<Range, Delim> const& p) ->
  basic_ostream<CharT, Traits>&
{
  if (!out)
    return out;
  
  auto const formatting = stream_formatting_saver<CharT, Traits>{out};
  
  auto first = true;
  
  for (auto const& i : p.range)
  {
    if (!first && !(out << p.delim))
      break;
    
    first = false;
    
    formatting.restore();
    
    if (!(out << i))
      break;
  }
  
  return out;
}

} // stream_range_detail

template <typename Range>
auto stream_range(Range&& r) ->
  stream_range_detail::stream_range_proxy<Range>
{
  return { forward<Range>(r) };
}

template <typename Range, typename Delim>
auto stream_range(Range&& r, Delim&& d) ->
  stream_range_detail::stream_range_delimited_proxy<Range, Delim>
{
  return { forward<Range>(r), forward<Delim>(d) };
}

template <typename Iterator>
auto stream_iterator_range(Iterator b, Iterator e) ->
  stream_range_detail::stream_range_proxy<stream_range_detail::iterator_range<Iterator>>
{
  return { stream_range_detail::make_iterator_range(b, e) };
}

template <typename OutputIterator, typename Delim>
auto stream_iterator_range(OutputIterator b, OutputIterator e, Delim&& d) ->
  stream_range_detail::stream_range_delimited_proxy<stream_range_detail::iterator_range<OutputIterator>, Delim>
{
  return { stream_range_detail::make_iterator_range(b, e), forward<Delim>(d) };
}

/*# Implementations for back_insert() ########################################*/

/* 
 * This is the helper class for back_insert().
 * 
 * back_insert() returns an object of this type, which holds a reference to the
 * range that the input will be pushed into using push_back().
 * 
 * This type also holds a count of the number of elements successfully read in
 * the last read operation. Initially it is zero, and it is reset on each read
 * operation. It can be retrieved with the count() member function.
 * 
 * This type also holds an instance of the value type of the range. This is
 * necessary to support types that do not have a default constructor.
 * 
 * This type is non-copyable, but it is moveable. The only way to create one is
 * via back_insert().
 */
template <typename Range>
class range_back_inserter
{
public:
  // Make movable.
  range_back_inserter(range_back_inserter&&) = default;
  auto operator=(range_back_inserter&&) -> range_back_inserter& = default;
  
  // Count function returns the count from the last input.
  auto count() const noexcept -> size_t { return count_; }
  
private:
  // Reference to the range, obviously.
  Range& range_;
  
  // The maximum number of elements to read in a single operation.
  size_t const amount_ = 0;
  
  // An instance of the range's value type, to use as the target to read into.
  stream_range_detail::RangeValueType<Range> value_;
  
  // The number of elements read in the last read operation.
  size_t count_ = 0;
  
  range_back_inserter(Range& r, size_t n, stream_range_detail::RangeValueType<Range> v) :
    range_{r},
    amount_{n},
    value_{move(v)}
  {}
  
  // Remove default constructor.
  range_back_inserter() = delete;
  
  // Make non-copyable.
  range_back_inserter(range_back_inserter const&) = delete;
  auto operator=(range_back_inserter const&) -> range_back_inserter& = delete;
  
  // Friend declarations for extraction operators. Note that both lvalue and
  // rvalue versions are needed.
  template <typename CharT, typename Traits, typename Range2>
  friend auto operator>>(basic_istream<CharT, Traits>& in, range_back_inserter<Range2>& rbi) ->
    basic_istream<CharT, Traits>&;
  
  template <typename CharT, typename Traits, typename Range2>
  friend auto operator>>(basic_istream<CharT, Traits>& in, range_back_inserter<Range2>&& rbi) ->
    basic_istream<CharT, Traits>&;
  
  // Friend declarations for back_insert().
  friend auto back_insert<Range>(Range&, stream_range_detail::RangeValueType<Range>) -> range_back_inserter<Range>;
  friend auto back_insert<Range>(Range&) -> range_back_inserter<Range>;
  
  // Friend declarations for back_insert_n().
  friend auto back_insert_n<Range>(Range&, size_t, stream_range_detail::RangeValueType<Range>) -> range_back_inserter<Range>;
  friend auto back_insert_n<Range>(Range&, size_t) -> range_back_inserter<Range>;
};

/* 
 * These are the extraction operators for range_back_inserter. It is necessary
 * to have both an lvalue and and rvalue version, because back_insert() may be
 * used in two ways - like this:
 *   in >> back_insert(r);
 * or like this:
 *   auto p = back_insert(r);
 *   in >> p;
 *   // check p.count() for the number of elements read.
 */
template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, range_back_inserter<Range>& rbi) ->
  basic_istream<CharT, Traits>&
{
  rbi.count_ = 0;
  
  auto v = move(rbi.value_);
  
  auto const formatting = stream_range_detail::stream_formatting_saver<CharT, Traits>{in};
  
  auto n = rbi.amount_;
  while (n-- && in >> v)
  {
    rbi.range_.push_back(move(v));
    ++rbi.count_;
    
    formatting.restore();
  }
  
  in.width(0);
  
  return in;
}

template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, range_back_inserter<Range>&& rbi) ->
  basic_istream<CharT, Traits>&
{
  return in >> rbi;
}

/* 
 * The back_insert() functions.
 * 
 * One version of this function allows you to pass an object of the range's
 * value type as an argument. This value is used as the initial value when
 * reading (because the nature of using istreams to read is that you need an
 * extant value of the type to read into). This allows you to use types that
 * don't have an accessible default constructor.
 * 
 * The second version simply calls the first version with a default-constructed
 * instance of the range's value type.
 */
template <typename Range>
auto back_insert(Range& r, stream_range_detail::RangeValueType<Range> t) ->
  range_back_inserter<Range>
{
  return {r, size_t{0} - 1, move(t)};
}

template <typename Range>
auto back_insert(Range& r) -> range_back_inserter<Range>
{
  return back_insert(r, stream_range_detail::RangeValueType<Range>{});
}

/* 
 * The back_insert_n() functions.
 * 
 * One version of this function allows you to pass an object of the range's
 * value type as an argument. This value is used as the initial value when
 * reading (because the nature of using istreams to read is that you need an
 * extant value of the type to read into). This allows you to use types that
 * don't have an accessible default constructor.
 * 
 * The second version simply calls the first version with a default-constructed
 * instance of the range's value type.
 */
template <typename Range>
auto back_insert_n(Range& r, size_t n, stream_range_detail::RangeValueType<Range> t) ->
  range_back_inserter<Range>
{
  return {r, n, move(t)};
}

template <typename Range>
auto back_insert_n(Range& r, size_t n) -> range_back_inserter<Range>
{
  return back_insert_n(r, n, stream_range_detail::RangeValueType<Range>{});
}

/*# Implementations for front_insert() #######################################*/

/* 
 * This is the helper class for front_insert().
 * 
 * front_insert() returns an object of this type, which holds a reference to the
 * range that the input will be pushed into using push_front().
 * 
 * This type also holds a count of the number of elements successfully read in
 * the last read operation. Initially it is zero, and it is reset on each read
 * operation. It can be retrieved with the count() member function.
 * 
 * This type also holds an instance of the value type of the range. This is
 * necessary to support types that do not have a default constructor.
 * 
 * This type is non-copyable, but it is moveable. The only way to create one is
 * via front_insert().
 */
template <typename Range>
class range_front_inserter
{
public:
  // Make movable.
  range_front_inserter(range_front_inserter&&) = default;
  auto operator=(range_front_inserter&&) -> range_front_inserter& = default;
  
  // Count function returns the count from the last input.
  auto count() const noexcept -> size_t { return count_; }
  
private:
  // Reference to the range, obviously.
  Range& range_;
  
  // The maximum number of elements to read in a single operation.
  size_t const amount_ = 0;
  
  // An instance of the range's value type, to use as the target to read into.
  stream_range_detail::RangeValueType<Range> value_;
  
  // The number of elements read in the last read operation.
  size_t count_ = 0;
  
  range_front_inserter(Range& r, size_t n, stream_range_detail::RangeValueType<Range> v) :
    range_{r},
    amount_{n},
    value_{move(v)}
  {}
  
  // Remove default constructor.
  range_front_inserter() = delete;
  
  // Make non-copyable.
  range_front_inserter(range_front_inserter const&) = delete;
  auto operator=(range_front_inserter const&) -> range_front_inserter& = delete;
  
  // Friend declarations for extraction operators. Note that both lvalue and
  // rvalue versions are needed.
  template <typename CharT, typename Traits, typename Range2>
  friend auto operator>>(basic_istream<CharT, Traits>& in, range_front_inserter<Range2>& rbi) ->
    basic_istream<CharT, Traits>&;
  
  template <typename CharT, typename Traits, typename Range2>
  friend auto operator>>(basic_istream<CharT, Traits>& in, range_front_inserter<Range2>&& rbi) ->
    basic_istream<CharT, Traits>&;
  
  // Friend declarations for front_insert().
  friend auto front_insert<Range>(Range&, stream_range_detail::RangeValueType<Range>) -> range_front_inserter<Range>;
  friend auto front_insert<Range>(Range&) -> range_front_inserter<Range>;
  
  // Friend declarations for front_insert_n().
  friend auto front_insert_n<Range>(Range&, size_t, stream_range_detail::RangeValueType<Range>) -> range_front_inserter<Range>;
  friend auto front_insert_n<Range>(Range&, size_t) -> range_front_inserter<Range>;
};

/* 
 * These are the extraction operators for range_front_inserter. It is necessary
 * to have both an lvalue and and rvalue version, because front_insert() may be
 * used in two ways - like this:
 *   in >> front_insert(r);
 * or like this:
 *   auto p = front_insert(r);
 *   in >> p;
 *   // check p.count() for the number of elements read.
 */
template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, range_front_inserter<Range>& rfi) ->
  basic_istream<CharT, Traits>&
{
  rfi.count_ = 0;
  
  auto v = move(rfi.value_);
  
  auto const formatting = stream_range_detail::stream_formatting_saver<CharT, Traits>{in};
  
  auto n = rfi.amount_;
  while (n-- && in >> v)
  {
    rfi.range_.push_front(move(v));
    ++rfi.count_;
    
    formatting.restore();
  }
  
  in.width(0);
  
  return in;
}

template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, range_front_inserter<Range>&& rfi) ->
  basic_istream<CharT, Traits>&
{
  return in >> rfi;
}

/* 
 * The front_insert() functions.
 * 
 * One version of this function allows you to pass an object of the range's
 * value type as an argument. This value is used as the initial value when
 * reading (because the nature of using istreams to read is that you need an
 * extant value of the type to read into). This allows you to use types that
 * don't have an accessible default constructor.
 * 
 * The second version simply calls the first version with a default-constructed
 * instance of the range's value type.
 */
template <typename Range>
auto front_insert(Range& r, stream_range_detail::RangeValueType<Range> t) ->
  range_front_inserter<Range>
{
  return {r, size_t{0} - 1, move(t)};
}

template <typename Range>
auto front_insert(Range& r) -> range_front_inserter<Range>
{
  return front_insert(r, stream_range_detail::RangeValueType<Range>{});
}

/* 
 * The front_insert_n() functions.
 * 
 * One version of this function allows you to pass an object of the range's
 * value type as an argument. This value is used as the initial value when
 * reading (because the nature of using istreams to read is that you need an
 * extant value of the type to read into). This allows you to use types that
 * don't have an accessible default constructor.
 * 
 * The second version simply calls the first version with a default-constructed
 * instance of the range's value type.
 */
template <typename Range>
auto front_insert_n(Range& r, size_t n, stream_range_detail::RangeValueType<Range> t) ->
  range_front_inserter<Range>
{
  return {r, n, move(t)};
}

template <typename Range>
auto front_insert_n(Range& r, size_t n) -> range_front_inserter<Range>
{
  return front_insert_n(r, n, stream_range_detail::RangeValueType<Range>{});
}

/*# Implementations for insert() #############################################*/

/* 
 * This is the helper class for insert().
 * 
 * insert() returns an object of this type, which holds a reference to the
 * range that the input will be pushed into using push_front().
 * 
 * This type also holds a count of the number of elements successfully read in
 * the last read operation. Initially it is zero, and it is reset on each read
 * operation. It can be retrieved with the count() member function.
 * 
 * This type also holds an instance of the value type of the range. This is
 * necessary to support types that do not have a default constructor.
 * 
 * This type is non-copyable, but it is moveable. The only way to create one is
 * via insert().
 */
template <typename Range>
class range_inserter
{
public:
  // Make movable.
  range_inserter(range_inserter&&) = default;
  auto operator=(range_inserter&&) -> range_inserter& = default;
  
  // Count function returns the count from the last input.
  auto count() const noexcept -> size_t { return count_; }
  
private:
  // Reference to the range, obviously.
  Range& range_;
  
  // The maximum number of elements to read in a single operation.
  stream_range_detail::RangeIterator<Range> it_;
  
  // The maximum number of elements to read in a single operation.
  size_t const amount_ = 0;
  
  // An instance of the range's value type, to use as the target to read into.
  stream_range_detail::RangeValueType<Range> value_;
  
  // The number of elements read in the last read operation.
  size_t count_ = 0;
  
  range_inserter(Range& r, stream_range_detail::RangeIterator<Range> i,
                 size_t n, stream_range_detail::RangeValueType<Range> v) :
    range_{r},
    it_{i},
    amount_{n},
    value_{move(v)}
  {}
  
  // Remove default constructor.
  range_inserter() = delete;
  
  // Make non-copyable.
  range_inserter(range_inserter const&) = delete;
  auto operator=(range_inserter const&) -> range_inserter& = delete;
  
  // Friend declarations for extraction operators. Note that both lvalue and
  // rvalue versions are needed.
  template <typename CharT, typename Traits, typename Range2>
  friend auto operator>>(basic_istream<CharT, Traits>& in, range_inserter<Range2>& rbi) ->
    basic_istream<CharT, Traits>&;
  
  template <typename CharT, typename Traits, typename Range2>
  friend auto operator>>(basic_istream<CharT, Traits>& in, range_inserter<Range2>&& rbi) ->
    basic_istream<CharT, Traits>&;
  
  // Friend declarations for insert().
  friend auto insert<Range>(Range&, stream_range_detail::RangeIterator<Range>, stream_range_detail::RangeValueType<Range>) -> range_inserter<Range>;
  friend auto insert<Range>(Range&, stream_range_detail::RangeIterator<Range>) -> range_inserter<Range>;
  
  // Friend declarations for insert_n().
  friend auto insert_n<Range>(Range&, stream_range_detail::RangeIterator<Range>, size_t, stream_range_detail::RangeValueType<Range>) -> range_inserter<Range>;
  friend auto insert_n<Range>(Range&, stream_range_detail::RangeIterator<Range>, size_t) -> range_inserter<Range>;
};

/* 
 * These are the extraction operators for range_inserter. It is necessary
 * to have both an lvalue and and rvalue version, because insert() may be
 * used in two ways - like this:
 *   in >> insert(r);
 * or like this:
 *   auto p = insert(r);
 *   in >> p;
 *   // check p.count() for the number of elements read.
 */
template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, range_inserter<Range>& ri) ->
  basic_istream<CharT, Traits>&
{
  ri.count_ = 0;
  
  auto v = move(ri.value_);
  
  auto const formatting = stream_range_detail::stream_formatting_saver<CharT, Traits>{in};
  
  auto n = ri.amount_;
  while (n-- && in >> v)
  {
    ri.it_ = ++ri.range_.insert(ri.it_, move(v));
    ++ri.count_;
    
    formatting.restore();
  }
  
  in.width(0);
  
  return in;
}

template <typename CharT, typename Traits, typename Range>
auto operator>>(basic_istream<CharT, Traits>& in, range_inserter<Range>&& ri) ->
  basic_istream<CharT, Traits>&
{
  return in >> ri;
}

/* 
 * The insert() functions.
 * 
 * One version of this function allows you to pass an object of the range's
 * value type as an argument. This value is used as the initial value when
 * reading (because the nature of using istreams to read is that you need an
 * extant value of the type to read into). This allows you to use types that
 * don't have an accessible default constructor.
 * 
 * The second version simply calls the first version with a default-constructed
 * instance of the range's value type.
 */
template <typename Range>
auto insert(Range& r, stream_range_detail::RangeIterator<Range> i, stream_range_detail::RangeValueType<Range> t) ->
  range_inserter<Range>
{
  return {r, i, size_t{0} - 1, move(t)};
}

template <typename Range>
auto insert(Range& r, stream_range_detail::RangeIterator<Range> i) -> range_inserter<Range>
{
  return insert(r, i, stream_range_detail::RangeValueType<Range>{});
}

/* 
 * The insert_n() functions.
 * 
 * One version of this function allows you to pass an object of the range's
 * value type as an argument. This value is used as the initial value when
 * reading (because the nature of using istreams to read is that you need an
 * extant value of the type to read into). This allows you to use types that
 * don't have an accessible default constructor.
 * 
 * The second version simply calls the first version with a default-constructed
 * instance of the range's value type.
 */
template <typename Range>
auto insert_n(Range& r, stream_range_detail::RangeIterator<Range> i, size_t n, stream_range_detail::RangeValueType<Range> t) ->
  range_inserter<Range>
{
  return {r, i, n, move(t)};
}

template <typename Range>
auto insert_n(Range& r, stream_range_detail::RangeIterator<Range> i, size_t n) -> range_inserter<Range>
{
  return insert_n(r, i, n, stream_range_detail::RangeValueType<Range>{});
}

} // namespace std

#endif // STD_STREAM_RANGE_
