<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta charset="utf-8"/>
	
	<title>Reference</title>
	
	<link rel="stylesheet" href="style/style.css"/>
	<link rel="stylesheet" href="style/reference.css"/>
	<link rel="stylesheet" href="style/code.css"/>
</head>
<body>
<main>
<section id="contents">
<h1>Contents</h1>

<ol class="toc">
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#input">Input</a>
    <ol>
      <li><a href="#input-reference">Reference</a></li>
    </ol>
  </li>
  <li><a href="#output">Output</a>
    <ol>
      <li><a href="#input-reference">Reference</a></li>
    </ol>
  </li>
</ol>
</section>
<section id="intro">
<h1>Introduction</h1>

<p>
  C++11 introduced the ‘range-<code class="lang-cpp"><span class="keyword">for</span></code>’ construct, which was the first step toward making ranges first-class citizens in the language.
  The concept is still being developed, but for now we can say that a range is anything that has <code class="lang-cpp">begin<span class="delim">()</span></code> and <code class="lang-cpp">end<span class="delim">()</span></code> member functions, or that works with <code class="lang-cpp">begin<span class="delim">()</span></code> and <code class="lang-cpp">end<span class="delim">()</span></code> free functions – either <code class="lang-cpp">std<span class="delim">::</span>begin<span class="delim">()</span></code>/<code class="lang-cpp">std<span class="delim">::</span>begin<span class="delim">()</span></code>, or <code class="lang-cpp">begin<span class="delim">()</span></code>/<code class="lang-cpp">end<span class="delim">()</span></code> as found by <abbr title="argument-dependent lookup">ADL</abbr> – that in either case return a type that satisfies the Iterator concept, where the return value from <code class="lang-cpp">begin<span class="delim">()</span></code> references the beginning of a sequence and the return value from <code class="lang-cpp">end<span class="delim">()</span></code> references one-past-the end of the same sequence.
  That’s a mouthful, but in brief you can say:
</p>
<div class="note">
  <p>
    If it works with range-<code class="lang-cpp"><span class="keyword">for</span></code>, it’s a range.
  </p>
</div>
<p>
  It is possible that future standards will include a whole new algorithms library that works with ranges rather than iterator pairs.
  That would be neat, because it would mean that verbose function calls like these:
</p>
<pre><code class="lang-cpp"><span class="keyword">using</span> std<span class="delim">::</span>begin<span class="delim">;</span>
<span class="keyword">using</span> std<span class="delim">::</span>end<span class="delim">;</span>

std<span class="delim">::</span>sort<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">));</span>
std<span class="delim">::</span>set_difference<span class="delim">(</span>begin<span class="delim">(</span>a<span class="delim">),</span> end<span class="delim">(</span>a<span class="delim">),</span> begin<span class="delim">(</span>b<span class="delim">),</span> end<span class="delim">(</span>b<span class="delim">),</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>c<span class="delim">));</span>
</code></pre>
<p>
  can be simplified to this:
</p>
<pre><code class="lang-cpp">std<span class="delim">::</span>sort<span class="delim">(</span>r<span class="delim">);</span>
std<span class="delim">::</span>set_difference<span class="delim">(</span>a<span class="delim">,</span> b<span class="delim">,</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>c<span class="delim">));</span>
</code></pre>
<p>
  which has the additional benefit of eliminating the possibility of mixing up iterators to different ranges.
</p>
<p>
  Whether or not that happens, the range concept is still a very nice one to work with, and one that we already tend to use.
</p>
<p>
  Unfortunately, C++ has never had a natural way to use ranges – even ranges defined by a pair of iterators – with IOStreams.
  The best the standard library has had to offer is stream iterators, most commonly used with the <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> algorithm, which looks like this:
</p>
<pre><code class="lang-cpp"><span class="comment">// Output</span>
std<span class="delim">::</span>copy<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> std<span class="delim">::</span>ostream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>out<span class="delim">,</span> <span class="literal string">"\n"</span><span class="delim">});</span>

<span class="comment">// Input - note: if you don't use braces, watch out for the most vexing parse!</span>
std<span class="delim">::</span>copy<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>in<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{},</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>c<span class="delim">));</span>
</code></pre>
<p>
  Stream iterators have the neat ability to be plugged into any algorithm that takes input and output iterators, so you can do some really cool things like read values from two different files, add each pair, and output the results to a third file in one statement:
</p>
<pre><code class="lang-cpp">std<span class="delim">::</span>transform<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>in1<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{},</span>
               std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>in2<span class="delim">},</span> std<span class="delim">::</span>ostream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>out<span class="delim">,</span> <span class="literal string">"\n"</span><span class="delim">},</span>
               std<span class="delim">::</span>plus<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{});</span></code></pre>
<p>
  Using stream iterators with algorithms is a little verbose and clunky.
  But the real problem is that there is no way to detect stream errors.
  In the previous example, if reading from one of the two files (particularly <code class="lang-cpp">in2</code>) fails at some point – either because of a malformed entry, premature end-of-file, or an I/O error – the algorithm will continue merrily pumping garbage values into the output file... and you will have no idea that something went wrong, let alone where.
</p>
<p>
  This proposal is about a new library that will not only fix those shortcomings, it will make reading and writing ranges a breeze.
</p>
</section>
<section id="input">
<h1>Input</h1>

<p>
  The standard way input works in C++ is that you create a variable of the type you wish to read, then use the extraction operator (<code class="lang-cpp"><span class="delim">&gt;&gt;</span></code>) to read it, like this:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> v <span class="delim">=</span> <span class="keyword">double</span><span class="delim">{};</span>
in <span class="delim">&gt;&gt;</span> v<span class="delim">;</span></code></pre>
<p>
  The proposal uses the same paradigm.
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> v <span class="delim">=</span> std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{};</span>
in <span class="delim">&gt;&gt;</span> <i>function</i><span class="delim">(</span>v<span class="delim">);</span></code></pre>
<p>
  Where <var>function</var> is one of the range input functions (described below).
</p>
<p>
  Whichever function is used, the basic pattern is the same:
</p>
<ol>
  <li>
    At the start of reading, the internal counter is set to zero, and the initial formatting state (flags, width, fill character, and precision) of the stream is saved.
  </li>
  <li>
    A buffer variable <code class="lang-cpp">v</code> of the range’s <code class="lang-cpp">value_type</code> is prepared (the details of this are described in the comments on non-default-constructable types).
  </li>
  <li>
    The initial formatting state of the stream is restored.
  </li>
  <li>
    An attempt is made to read and parse a value from <code class="lang-cpp">in</code>, and store it in <code class="lang-cpp">v</code> (using <code class="lang-cpp">in <span class="delim">&gt;&gt;</span> v</code>).
    If this makes <code class="lang-cpp"><span class="keyword">bool</span><span class="delim">(</span>in<span class="delim">)</span></code> return <code class="lang-cpp"><span class="keyword">false</span></code> (either by a stream I/O error, or a parse error), go to 7.
  </li>
  <li>
    The value in <code class="lang-cpp">v</code> is added to range in some way (dependent on the function), and the internal counter is increased.
  </li>
  <li>
    If the number of values desired (as determined by the reading function, and it may be functionally infinite) has not yet been read, go to 3.
  </li>
  <li>
    Set the stream width to zero.
  </li>
  <li>
    Return a reference to <code class="lang-cpp">in</code>.
  </li>
</ol>
<p>
  The idea is that no matter which input function you use, the following code will work identically, with some assumptions (specifically, that the number of values wanted is the same as the number of values available in the input sequence), regardless of whether one, zero, or many values are read before the string:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{};</span>
<span class="keyword">auto</span> s <span class="delim">=</span> std<span class="delim">::</span>string<span class="delim">{};</span>

in <span class="delim">&gt;&gt;</span> <i>function</i><span class="delim">(</span>r<span class="delim">);</span>
in<span class="delim">.</span>clear<span class="delim">();</span>
in <span class="delim">&gt;&gt;</span> s<span class="delim">;</span></code></pre>
<p>
  (The <code class="lang-cpp">clear()</code> function is used because some input functions read until the stream’s fail state is set.)
</p>
<p>
  Error checking is done simply by checking the stream’s state flags, as is natural for input.
  In the event that a failure is detected, it is possible to determine the number of values that were successfully read by capturing the proxy object returned by an input function and checking its <code class="lang-cpp">count()</code> member function, like this:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{};</span>

<span class="keyword">auto</span> p <span class="delim">=</span> <i>function</i><span class="delim">(</span>r<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> p<span class="delim">;</span>

std<span class="delim">::</span>cout <span class="delim">&lt;&lt;</span> p<span class="delim">.</span>count<span class="delim">()</span> <span class="delim">&lt;&lt;</span> <span class="literal string">" values were read."</span><span class="delim">;</span></code></pre>
<div class="warn">
  <p>
    Because the proxy object keeps a reference to the range, the effect of using it after the range’s lifetime has expired is undefined behaviour.
  </p>
</div>
<div class="query">
  <p>
    Should the proxy object also keep an iterator to the next spot in the range?
    That is, the value that would be returned from <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> if used in the canonical input way?
  </p>
</div>
<p>
  There are four different input functions provided by this proposal.
  The operations they perform are:
</p>
<ul>
  <li>
    Overwriting the values in the range with values read from the input stream.
  </li>
  <li>
    Pushing values read from the input stream onto the back of the range.
  </li>
  <li>
    Pushing values read from the input stream onto the front of the range.
  </li>
  <li>
    Inserting values read from the input stream into the range (at any arbitrary point).
  </li>
</ul>
<p>
  They look like this:
</p>
<pre><code class="lang-cpp">in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>overwrite<span class="delim">(</span>r<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>back_insert<span class="delim">(</span>r<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>front_insert<span class="delim">(</span>r<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>insert<span class="delim">(</span>r<span class="delim">,</span> pos<span class="delim">);</span></code></pre>
<p>
  These four ways roughly map to the existing four ways you would use stream iterators and <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> for input.
  In order, they are analogous to:
</p>
<pre><code class="lang-cpp"><span class="comment">// assuming r is a range of type Range</span>

std<span class="delim">::</span>copy_n<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{</span>in<span class="delim">},</span> r<span class="delim">.</span>size<span class="delim">(),</span> r<span class="delim">.</span>begin<span class="delim">());</span>
std<span class="delim">::</span>copy<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{</span>in<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{},</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>r<span class="delim">));</span>
std<span class="delim">::</span>copy<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{</span>in<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{},</span> std<span class="delim">::</span>front_inserter<span class="delim">(</span>r<span class="delim">));</span>
std<span class="delim">::</span>copy<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{</span>in<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span>Range<span class="delim">::</span>value_type<span class="delim">&gt;{},</span> std<span class="delim">::</span>inserter<span class="delim">(</span>r<span class="delim">,</span> pos<span class="delim">));</span></code></pre>
<p>
  but they are safer, easier to use, and have some neat extra features that make them useful in situations where the <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> solution just won’t work.
</p>
<p>
  The latter three operations are different from the overwrite operation, because overwrite has an existing set of values in the range to work with, while the others are creating new values.
  This means the three ‘insert’ operations have a few more challenges to overcome, and therefore some features to help overcome those challenges.
</p>
<p>
  First, each of the ‘insert’ operations has a related ‘insert n’ operation.
  Regular ‘insert’ operations read until reading fails; the ‘insert n’ operations stop reading after the specified number of values have been read, even if more are available.
  They look like this:
</p>
<pre><code class="lang-cpp">in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>back_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>front_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>insert_n<span class="delim">(</span>r<span class="delim">,</span> pos<span class="delim">,</span> n<span class="delim">);</span></code></pre>
<div class="query">
  <p>
    Should the ‘insert n’ functions be folded into the ‘insert’ functions as overloads, rather than as separate functions?
  </p>
</div>
<p>
  Finally, there is one more technical hurdle that the ‘insert’ functions have to handle.
  In C++, input from a stream requires that you already have an object of the desired type.
  In other words, the variable <code class="lang-cpp">v</code> in the code below has to exist before the input operation:
</p>
<pre><code class="lang-cpp">in <span class="delim">&gt;&gt;</span> v<span class="delim">;</span></code></pre>
<p>
  That means that the ‘insert’ functions have to create an instance of the range’s value type to use as a buffer for reading.
  The question is: how?
  The easy answer – and the one currently used by the family of ‘insert iterators’ (<code class="lang-cpp">std<span class="delim">::</span>back_insert_iterator</code>, <code class="lang-cpp">std<span class="delim">::</span>front_insert_iterator</code>, and <code class="lang-cpp">std<span class="delim">::</span>insert_iterator</code>) – is to simply default-construct an instance of the desired type.
  That’s fine normally... but not so much for types that don’t have an accessible default constructor (or don’t have one at all).
</p>
<p>
  To support those types, all of the ‘insert’ (and ‘insert n’) functions take an additional argument: an instance of the range’s value type.
  This serves as the initial value used for the buffer.
</p>
<pre><code class="lang-cpp">in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>back_insert<span class="delim">(</span>r<span class="delim">,</span> v<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>front_insert<span class="delim">(</span>r<span class="delim">,</span> v<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>insert<span class="delim">(</span>r<span class="delim">,</span> pos<span class="delim">,</span> v<span class="delim">);</span>

in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>back_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">,</span> v<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>front_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">,</span> v<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> std<span class="delim">::</span>insert_n<span class="delim">(</span>r<span class="delim">,</span> pos<span class="delim">,</span> n<span class="delim">,</span> v<span class="delim">);</span></code></pre>
<p>
  If <code class="lang-cpp">v</code> is a default-constructed value of the range’s <code class="lang-cpp">value_type</code>, each of the lines above is equivalent to the overload without <code class="lang-cpp">v</code>.
</p>
<div class="warn">
  <p>
    Do not assume the buffer variable will actually be set to the value given to the input function on each read.
    It might be set to that value on the first read, but then it might be overwritten or moved-from before subsequent reads.
  </p>
</div>
<section id="input-reference">
<h1>Reference</h1>

<p>
  Range input function reference:
</p>
<table class="function-reference">
  <thead>
    <tr>
      <th>Function</th>
      <th>Arguments</th>
      <th>Effects</th>
      <th>Supports</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">overwrite<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Overwrites each element in <var>r</var> with successive values.</li>
          <li>Stops when <var>r</var> is completely overwritten, or after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li>C arrays of known bound</li>
          <li><code class="lang-cpp">std<span class="delim">::</span>array</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>forward_list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>valarray</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">back_insert<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the end of <var>r</var> using <code class="lang-cpp">push_back<span class="delim">()</span></code>.</li>
          <li>Stops after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">back_insert<span class="delim">(</span>r<span class="delim">,</span> v<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>v</var></dt>
          <dd>A instance of the <code class="lang-cpp">value_type</code> of <var>r</var></dd>
        </dl>
      </td>
      <td>
        Same as above.
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">back_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the end of <var>r</var> using <code class="lang-cpp">push_back<span class="delim">()</span></code>.</li>
          <li>Stops after <var>n</var> values are read, or after a read failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">back_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">,</span> v<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
          <dt><var>v</var></dt>
          <dd>A instance of the <code class="lang-cpp">value_type</code> of <var>r</var></dd>
        </dl>
      </td>
      <td>
        Same as above.
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">front_insert<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the start of <var>r</var> using <code class="lang-cpp">push_front<span class="delim">()</span></code>.</li>
          <li>Stops after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>forward_list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">front_insert<span class="delim">(</span>r<span class="delim">,</span> v<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>v</var></dt>
          <dd>A instance of the <code class="lang-cpp">value_type</code> of <var>r</var></dd>
        </dl>
      </td>
      <td>
        Same as above.
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">front_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the start of <var>r</var> using <code class="lang-cpp">push_front<span class="delim">()</span></code>.</li>
          <li>Stops after <var>n</var> values are read, or after a read failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">front_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">,</span> v<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
          <dt><var>v</var></dt>
          <dd>A instance of the <code class="lang-cpp">value_type</code> of <var>r</var></dd>
        </dl>
      </td>
      <td>
        Same as above.
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">insert<span class="delim">(</span>r<span class="delim">,</span> p<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>p</var></dt>
          <dd>Iterator for <var>r</var></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to <var>r</var> before the element referenced by <var>p</var> using <code class="lang-cpp">insert<span class="delim">()</span></code>.</li>
          <li>Stops after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">insert<span class="delim">(</span>r<span class="delim">,</span> p<span class="delim">,</span> v<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>p</var></dt>
          <dd>Iterator for <var>r</var></dd>
          <dt><var>v</var></dt>
          <dd>A instance of the <code class="lang-cpp">value_type</code> of <var>r</var></dd>
        </dl>
      </td>
      <td>
        Same as above.
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">insert_n<span class="delim">(</span>r<span class="delim">,</span> p<span class="delim">,</span> n<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>p</var></dt>
          <dd>Iterator for <var>r</var></dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to <var>r</var> before the element referenced by <var>p</var> using <code class="lang-cpp">insert<span class="delim">()</span></code>.</li>
          <li>Stops after <var>n</var> values are read, or after a read failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">insert_n<span class="delim">(</span>r<span class="delim">,</span> p<span class="delim">,</span> n<span class="delim">,</span> v<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>p</var></dt>
          <dd>Iterator for <var>r</var></dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
          <dt><var>v</var></dt>
          <dd>A instance of the <code class="lang-cpp">value_type</code> of <var>r</var></dd>
        </dl>
      </td>
      <td>
        Same as above.
      </td>
      <td>
        Same as above.
      </td>
    </tr>
  </tbody>
</table>

<p>
  Every range input function returns a proxy object that references the range.
  The proxy object cannot be default-constructed (it must be constructed by a range input function), and it satisfies the following concepts:
</p>
<ul>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/Destructible">Destructible</a></code></li>
</ul>
<p>
  The proxy object has the following member functions:
</p>
<table class="proxy-reference">
  <thead>
    <tr>
      <th>Function</th>
      <th>Arguments</th>
      <th>Returns</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">count<span class="delim">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></code></td>
      <td>―</td>
      <td><code class="lang-cpp">size_t</code></td>
      <td>The number of elements that were successfully read in the last input operation.</td>
    </tr>
  </tbody>
</table>
</section>
</section>
<section id="output">
<h1>Output</h1>

<p>
  Output of ranges works like like the output of anything else:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> v <span class="delim">=</span> std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">4</span> <span class="delim">};</span>
out <span class="delim">&lt;&lt;</span> std<span class="delim">::</span>write_all<span class="delim">(</span>v<span class="delim">);</span>
<span class="comment">// Output: "1234"</span></code></pre>
<p>
  It is even possible to output rvalues:
</p>
<pre><code class="lang-cpp">out <span class="delim">&lt;&lt;</span> std<span class="delim">::</span>write_all<span class="delim">(</span>std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">4</span> <span class="delim">});</span>
<span class="comment">// Output: "1234"</span></code></pre>
<p>
  <code class="lang-cpp">write_all<span class="delim">()</span></code> simply writes each value in the range to the output sequence in turn, ensuring that the formatting used to write the first element is used for all elements.
  It is possible to add a delimiter that is printed between elements:
</p>
<pre><code class="lang-cpp">out <span class="delim">&lt;&lt;</span> std<span class="delim">::</span>write_all<span class="delim">(</span>std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">4</span> <span class="delim">},</span> <span class="literal char">','</span><span class="delim">);</span>
<span class="comment">// Output: "1,2,3,4"</span></code></pre>
<p>
  Unlike with ostream iterators, the delimiter does not have to be a C string, allowing you to use real strings, or any type that can be streamed, and even function objects.
</p>
<p>
  <code class="lang-cpp">write_all<span class="delim">()</span></code> is designed so that if the range contains only a single element, then the following two statements should produce identical results:
</p>
<pre><code class="lang-cpp">out <span class="delim">&lt;&lt;</span> std<span class="delim">::</span>write_all<span class="delim">(</span>v<span class="delim">);</span>
<span class="comment">// If v has only one element, identical to:</span>
out <span class="delim">&lt;&lt;</span> <span class="delim">*</span>std<span class="delim">::</span>begin<span class="delim">(</span>v<span class="delim">)</span> <span class="delim">&lt;&lt;</span> std<span class="delim">::</span>setw<span class="delim">(</span><span class="literal int">0</span><span class="delim">);</span></code></pre>
<p>
  (Note that <code class="lang-cpp">write_all<span class="delim">()</span></code> will always reset the stream’s width to zero before returning.)
</p>
<p>
  If the range has more than one element, then each element should produce the same result as if it were the only element in a single element range (which means it should produce the same result as if it were used directly).
  When the range is empty, the stream’s fill character is written as many times as the stream’s width.
</p>
<pre><code class="lang-cpp"><span class="keyword">void</span> test<span class="delim">(</span>std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;</span> <span class="keyword">const</span><span class="delim">&amp;</span> r<span class="delim">)</span>
<span class="delim">{</span>
  std<span class="delim">::</span>cout<span class="delim">.</span>fill<span class="delim">(</span><span class="literal char">'_'</span><span class="delim">);</span>
  std<span class="delim">::</span>cout<span class="delim">.</span>width<span class="delim">(</span><span class="literal int">8</span><span class="delim">);</span>
  
  std<span class="delim">::</span>cout <span class="delim">&lt;&lt;</span> std<span class="delim">::</span>write_all<span class="delim">(</span>r<span class="delim">,</span> <span class="literal char">'|'</span><span class="delim">) &lt;&lt;</span> <span class="literal char">'\n'</span><span class="delim">;</span>
<span class="delim">}</span>

<span class="keyword">auto</span> v <span class="delim">=</span> std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{};</span>
test<span class="delim">(</span>v<span class="delim">);</span>
<span class="comment">// "________"</span>

v <span class="delim">=</span> <span class="delim">{</span> <span class="literal int">42</span> <span class="delim">};</span>
test<span class="delim">(</span>v<span class="delim">);</span>
<span class="comment">// "______42"</span>

v <span class="delim">=</span> <span class="delim">{</span> <span class="literal int">42</span><span class="delim">,</span> <span class="literal int">57</span><span class="delim">,</span> <span class="literal int">69</span> <span class="delim">};</span>
test<span class="delim">(</span>v<span class="delim">);</span>
<span class="comment">// "______42|______57|______69"</span></code></pre>
<p>
  The delimiter, if any, is written after each element except the last (so if the range is empty or has only one element, it is not written at all), using whatever formatting exists after the element is written.
</p>
<p>
  Error checking is the same as for input.
  If there is an error while attempting to write a range, the stream’s conversion to <code class="lang-cpp"><span class="keyword">bool</span></code> will return <code class="lang-cpp"><span class="keyword">false</span></code>.
  The proxy object returned from <code class="lang-cpp">write_all<span class="delim">()</span></code> has a <code class="lang-cpp">count<span class="delim">()</span></code> function that can be queried to see how many elements of the range were written.
</p>
<section id="output-reference">
<h1>Reference</h1>

<p>
  Range output function reference:
</p>
<table class="function-reference">
  <thead>
    <tr>
      <th>Function</th>
      <th>Arguments</th>
      <th>Effects</th>
      <th>Supports</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">write_all<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd><code class="lang-cpp"><span class="keyword">const</span></code> lvalue reference or non-<code class="lang-cpp"><span class="keyword">const</span></code> rvalue reference to a range.</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Writes each element in <var>r</var> to the output stream successively.</li>
          <li>Stops when <var>r</var> is completely written, or after a write failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li>C arrays of known bound</li>
          <li><code class="lang-cpp">std<span class="delim">::</span>array</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>forward_list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>valarray</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">write_all<span class="delim">(</span>r<span class="delim">,</span> d<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd><code class="lang-cpp"><span class="keyword">const</span></code> lvalue reference or non-<code class="lang-cpp"><span class="keyword">const</span></code> rvalue reference to a range.</dd>
          <dt><var>d</var></dt>
          <dd>An instance of a type that can be written to an output stream.</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Writes each element in <var>r</var> to the output stream successively.</li>
          <li>The delimiter <var>d</var> is written after each value, except the last.</li>
          <li>Stops when <var>r</var> is completely written, or after a write failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
  </tbody>
</table>

<p>
  Every range output function returns a proxy object that references the range, or – in the case of rvalues – takes ownership of the range (by moving).
  The proxy object cannot be default-constructed (it must be constructed by a range output function), and it satisfies the following concepts:
</p>
<ul>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/Destructible">Destructible</a></code></li>
</ul>
<p>
  The proxy object has the following member functions:
</p>
<table class="proxy-reference">
  <thead>
    <tr>
      <th>Function</th>
      <th>Arguments</th>
      <th>Returns</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">count<span class="delim">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></code></td>
      <td>―</td>
      <td><code class="lang-cpp">size_t</code></td>
      <td>The number of elements that were successfully written in the last output operation.</td>
    </tr>
  </tbody>
</table>
</section>
</section>
</main>
<footer>
  <dl id="version-info">
    <dt>Version</dt>
    <dd>1.4.0</dd>
    <dt>Date</dt>
    <dd><time>2014-07-25</time></dd>
  </dl>
  <p>
    For the latest version of the proposal, see <a href="https://github.com/DarkerStar/cpp-range-streaming">https://github.com/DarkerStar/cpp-range-streaming</a>.
  </p>
  <p id="copyright">
    © Copyright 2014 Mark A. Gibbs. All rights reserved.
  </p>
</footer>
</body>
</html>