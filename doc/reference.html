<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<meta charset="utf-8"/>
	
	<title>C++ range I/O reference</title>
	
	<link rel="stylesheet" href="style/style.css"/>
	<link rel="stylesheet" href="style/reference.css"/>
	<link rel="stylesheet" href="style/code.css"/>
</head>
<body>
<header>
<h1>C++ range <abbr>I/O</abbr> reference</h1>
</header>
<main>
<section id="contents">
<h1>Contents</h1>

<ol class="toc">
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#rangeio">Range <abbr>I/O</abbr></a>
    <ol>
      <li><a href="#rangeio-formatting">Formatting</a></li>
      <li><a href="#rangeio-error_handling">Error handling</a></li>
    </ol>
  </li>
  <li><a href="#reference">Reference</a>
    <ol>
      <li><a href="#reference-input">Input</a></li>
      <li><a href="#reference-output">Output</a></li>
    </ol>
  </li>
</ol>
</section>
<section id="motivation">
<h1>Motivation</h1>

<p>
  C++11 introduced the ‘range-<code class="lang-cpp"><span class="keyword">for</span></code>’ construct, which was the first step toward making ranges first-class citizens in the language.
  The concept is still being developed, but for now we can say that a range is anything that has <code class="lang-cpp">begin<span class="delim">()</span></code> and <code class="lang-cpp">end<span class="delim">()</span></code> member functions, or that works with <code class="lang-cpp">begin<span class="delim">()</span></code> and <code class="lang-cpp">end<span class="delim">()</span></code> free functions – either <code class="lang-cpp">std<span class="delim">::</span>begin<span class="delim">()</span></code>/<code class="lang-cpp">std<span class="delim">::</span>begin<span class="delim">()</span></code>, or <code class="lang-cpp">begin<span class="delim">()</span></code>/<code class="lang-cpp">end<span class="delim">()</span></code> as found by <abbr title="argument-dependent lookup">ADL</abbr> – that in either case return a type that satisfies the Iterator concept, where the return value from <code class="lang-cpp">begin<span class="delim">()</span></code> references the beginning of a sequence and the return value from <code class="lang-cpp">end<span class="delim">()</span></code> references one-past-the end of the same sequence.
  That’s a mouthful, but in brief you can say:
</p>
<div class="note">
  <p>
    If it works with range-<code class="lang-cpp"><span class="keyword">for</span></code>, it’s a range.
  </p>
</div>
<p>
  It is possible that future standards will include a whole new algorithms library that works with ranges rather than iterator pairs.
  That would be neat, because it would mean that verbose function calls like these:
</p>
<pre><code class="lang-cpp"><span class="keyword">using</span> std<span class="delim">::</span>begin<span class="delim">;</span>
<span class="keyword">using</span> std<span class="delim">::</span>end<span class="delim">;</span>

std<span class="delim">::</span>sort<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">));</span>
std<span class="delim">::</span>set_difference<span class="delim">(</span>begin<span class="delim">(</span>a<span class="delim">),</span> end<span class="delim">(</span>a<span class="delim">),</span> begin<span class="delim">(</span>b<span class="delim">),</span> end<span class="delim">(</span>b<span class="delim">),</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>c<span class="delim">));</span>
</code></pre>
<p>
  can be simplified to this:
</p>
<pre><code class="lang-cpp">std<span class="delim">::</span>sort<span class="delim">(</span>r<span class="delim">);</span>
std<span class="delim">::</span>set_difference<span class="delim">(</span>a<span class="delim">,</span> b<span class="delim">,</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>c<span class="delim">));</span>
</code></pre>
<p>
  which has the additional benefit of eliminating the possibility of mixing up iterators to different ranges.
</p>
<p>
  Whether or not that happens, the range concept is still a very nice one to work with, and one that we already tend to use.
</p>
<p>
  Unfortunately, C++ has never had a natural way to use ranges – even ranges defined by a pair of iterators – with IOStreams.
  The best the standard library has had to offer is stream iterators, most commonly used with the <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> algorithm, which looks like this:
</p>
<pre><code class="lang-cpp"><span class="comment">// Output</span>
std<span class="delim">::</span>copy<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> std<span class="delim">::</span>ostream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>out<span class="delim">,</span> <span class="literal string">"\n"</span><span class="delim">});</span>

<span class="comment">// Input - note: if you don't use braces, watch out for the most vexing parse!</span>
std<span class="delim">::</span>copy<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>in<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{},</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>c<span class="delim">));</span>
</code></pre>
<p>
  Stream iterators have the neat ability to be plugged into any algorithm that takes input and output iterators, so you can do some really cool things like read values from two different files, add each pair, and output the results to a third file in one statement:
</p>
<pre><code class="lang-cpp">std<span class="delim">::</span>transform<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>in1<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{},</span>
               std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>in2<span class="delim">},</span> std<span class="delim">::</span>ostream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>out<span class="delim">,</span> <span class="literal string">"\n"</span><span class="delim">},</span>
               std<span class="delim">::</span>plus<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{});</span></code></pre>
<p>
  The flexibility that stream iterators offer can’t easily be beat.
  Unfortunately, they’re a little clunky for the simplest and most common <abbr>I/O</abbr> tasks.
  Look again at what reading values from a stream into a range looks like:
</p>
<pre><code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>in<span class="delim">},</span> std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{},</span> std<span class="delim">::</span>back_inserter<span class="delim">(</span>r<span class="delim">));</span></code></pre>
<p>
  And this is writing a range to a stream:
</p>
<pre><code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> std<span class="delim">::</span>ostream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>out<span class="delim">,</span> <span class="literal string">"\n"</span><span class="delim">});</span></code></pre>
<p>
  Those statements are not just clunky, verbose, and unintuitive.
  The semantics are also wrong.
  <abbr>I/O</abbr> is not a copy operation.
  No one calls <code class="lang-cpp"><span class="keyword">operator</span><span class="delim">&lt;&lt;</span></code> or <code class="lang-cpp"><span class="keyword">operator</span><span class="delim">&gt;&gt;</span></code> copy operators.
</p>
<p>
  Even worse, they don’t really work all that well.
  Suppose you have a file with a known number of <code class="lang-cpp"><span class="keyword">double</span></code> values – say 30.
  How would you read them into a vector?
  Well, you might write something like this:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> std<span class="delim">::</span>vector<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;(</span><span class="literal int">30</span><span class="delim">);</span>
std<span class="delim">::</span>copy_n<span class="delim">(</span>std<span class="delim">::</span>istream_iterator<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">&gt;{</span>in<span class="delim">},</span> r<span class="delim">.</span>size<span class="delim">(),</span> begin<span class="delim">(</span>r<span class="delim">));</span></code></pre>
<p>
  If all goes well, that will work fine.
  However, if there is a problem reading, say, the fifth <code class="lang-cpp"><span class="keyword">double</span></code> value – either because the source data is corrupted or because there was an <abbr>I/O</abbr> error with the stream – what do you think will happen?
  What will happen is probably that the first four values of the vector will be legitimate, then the remaining twenty-six will simply be repetitions of the fourth value.
  Maybe.
  Here’s the really tricky question, though: how can you detect <em>where</em> the error occurred?
</p>
<p>
  The stream state will tell you that there was a read error at some point... but <em>where</em>?
  Are all the values in the vector okay but the last?
  Are only half okay?
  Are they all bad?
  You see, the algorithm will merrily chug away until 30 values have been “read” and “copied” – regardless of whether 30 values actually get read and copied or not.
  It’s just not designed for this kind of use.
</p>
<p>
  However, using <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> won’t work for this problem either, because that algorithm will copy values until it can’t anymore – it won’t stop at 30.
  Which means you’re stuck – you basically have to write your own algorithm that copies up to <var>n</var> values, stopping early if the “end” iterator is reached (which, with input stream iterators, is triggered when not more values can be read).
</p>
<p>
  You may think that may not be <em>that</em> bad, because “copy up to <var>n</var>” is probably a useful algorithm to have in your toolkit anyway.
  However, there’s yet another thorny issue to deal with: formatting.
</p>
<p>
  Algorithms and stream iterators have no awareness of stream formatting.
  You can get surprising and unpredictable results.
  Consider the following code, where <var>v</var> is a vector with <var>N</var> elements { 0, 1, 2, ..., <var>N-1</var> }:
</p>
<pre><code class="lang-cpp">out <span class="delim">&lt;&lt;</span> <span class="literal string">"{ "</span><span class="delim">;</span>
out<span class="delim">.</span>fill<span class="delim">(</span><span class="literal char">'0'</span><span class="delim">);</span>
out<span class="delim">.</span>width<span class="delim">(</span><span class="literal int">5</span><span class="delim">);</span>
std<span class="delim">::</span>copy<span class="delim">(</span>begin<span class="delim">(</span>v<span class="delim">),</span> end<span class="delim">(</span>v<span class="delim">),</span> std<span class="delim">::</span>ostream_iterator<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span>out<span class="delim">,</span> <span class="literal string">", "</span><span class="delim">});</span>
out <span class="delim">&lt;&lt;</span> <span class="literal string">" }\n"</span><span class="delim">;</span></code></pre>
<p>
  Clearly what is desired is to print the vector like this: “{ 00000, 00001, 00002, ... }”.
  Unfortunately, that’s not what you’re going to get – and even worse, you can’t predict exactly what’s going to happen without knowing the size of the vector.
  Here are some possible results:
</p>
<pre><samp>// v = { 0 }
{ 00000,  }

// v = { 0, 1, 2 }
{ 00000, 1, 2,  }

// v = { }
{ 00 }</samp></pre>
<p>
  Reading a bunch of values from a stream into a range, and writing the values in a range to a stream, are very basic, and very common operations.
  It should be easy, especially for beginners.
  Making it easy is the goal of this proposal.
</p>
</section>
<section id="rangeio">
<h1>Range <abbr>I/O</abbr></h1>

<p>
  This is what input of singular values looks like in C++:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> v <span class="delim">=</span> type<span class="delim">{};</span>
in <span class="delim">&gt;&gt;</span> v<span class="delim">;</span></code></pre>
<p>
  This is what output of singular values looks like:
</p>
<pre><code class="lang-cpp">out <span class="delim">&lt;&lt;</span> v<span class="delim">;</span></code></pre>
<p>
  One of the goals of this proposal was to make input and output of ranges as natural as possible, and to integrate it will with the existing <abbr>I/O</abbr> mechanisms.
  So this is what input of ranges looks like:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span>type<span class="delim">&gt;{};</span>
in <span class="delim">&gt;&gt;</span> back_insert<span class="delim">(</span>r<span class="delim">);</span></code></pre>
<p>
  And this is what output of ranges looks like:
</p>
<pre><code class="lang-cpp">out <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>r<span class="delim">);</span></code></pre>
<p>
  These operations integrate right into the existing input and output paradigms.
  For example, you can chain them:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">5</span> <span class="delim">};</span>
out <span class="delim">&lt;&lt;</span> <span class="literal string">"{ "</span> <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>r<span class="delim">,</span> <span class="literal string">", "</span><span class="delim">) &lt;&lt;</span> <span class="literal string">" }"</span><span class="delim">;</span>
<span class="line comment">// output: "{ 1, 1, 2, 3, 5 }"</span></code></pre>
<p>
  Output comes in two flavours – simple output that just prints each element of the range:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">char</span><span class="delim">&gt;{</span> <span class="literal char">'a'</span><span class="delim">,</span> <span class="literal char">'b'</span><span class="delim">,</span> <span class="literal char">'c'</span><span class="delim">,</span> <span class="literal char">'d'</span><span class="delim">,</span> <span class="literal char">'e'</span> <span class="delim">};</span>
out <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>r<span class="delim">);</span>
<span class="line comment">// output: "abcde"</span></code></pre>
<p>
  And delimited output, that prints each element of the range with a delimiter between each element:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">char</span><span class="delim">&gt;{</span> <span class="literal char">'a'</span><span class="delim">,</span> <span class="literal char">'b'</span><span class="delim">,</span> <span class="literal char">'c'</span><span class="delim">,</span> <span class="literal char">'d'</span><span class="delim">,</span> <span class="literal char">'e'</span> <span class="delim">};</span>
out <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>r<span class="delim">,</span> <span class="literal string">" and "</span><span class="delim">);</span>
<span class="line comment">// output: "a and b and c and d and e"</span></code></pre>
<p>
  Note that the delimiter is much more flexible than the ‘delimiter’ in ostream_iterator.
  It does not necessarily need to be a string – if the delimiter is a single character like a newline, you can just use it as a char – but you can even use a ‘smart’ delimiter:
</p>
<pre><code class="lang-cpp"><span class="keyword">struct</span> oxford_comma
<span class="delim">{</span>
  <span class="keyword">explicit</span> oxford_comma<span class="delim">(</span>size_t n<span class="delim">) :</span> n_<span class="delim">{--</span>n<span class="delim">} {}</span>
  
  size_t n_<span class="delim">;</span>
<span class="delim">};</span>

<span class="keyword">auto</span> <span class="keyword">operator</span><span class="delim">&lt;&lt;(</span>ostream<span class="delim">&amp;</span> o<span class="delim">,</span> oxford_comma<span class="delim">&amp;</span> c<span class="delim">) -&gt;</span> ostream<span class="delim">&amp;</span>
<span class="delim">{</span>
  <span class="keyword">if</span> <span class="delim">(!(--</span>n_<span class="delim">))</span>
    o <span class="delim">&lt;&lt;</span> <span class="literal string">", "</span><span class="delim">;</span>
  <span class="keyword">else</span>
    o <span class="delim">&lt;&lt;</span> <span class="literal string">", and "</span><span class="delim">;</span>
<span class="delim">}</span>

<span class="keyword">auto</span> benefits <span class="delim">=</span> vector<span class="delim">&lt;</span>string<span class="delim">&gt;{</span>
  <span class="literal string">"clearer"</span><span class="delim">,</span>
  <span class="literal string">"classier"</span><span class="delim">,</span>
  <span class="literal string">"more logical"</span>
<span class="delim">};</span>

cout <span class="delim">&lt;&lt;</span> <span class="literal string">"The Oxford comma is "</span> <span class="delim">&lt;&lt;</span>
        write_all<span class="delim">(</span>benefits<span class="delim">,</span> oxford_comma<span class="delim">(</span>benefits<span class="delim">.</span>size<span class="delim">())) &lt;&lt;</span>
        <span class="literal string">" than the barbaric alternatives."</span><span class="delim">;</span>

<span class="line comment">// The Oxford comma is clearer, classier, and more logical than the barbaric alternatives.</span></code></pre>
<p>
  With output, you can do any filtering you need on the range itself.
  For example, using <a href="http://www.boost.org/doc/libs/1_56_0/libs/range/doc/html/index.html">Boost.Range</a>’s range adaptors:
</p>
<pre><code class="lang-cpp"><span class="keyword">struct</span> is_odd <span class="delim">{</span> <span class="keyword">auto</span> <span class="keyword">operator</span><span class="delim">()(</span><span class="keyword">int</span> x<span class="delim">)</span> <span class="keyword">const</span> <span class="delim">{</span> <span class="keyword">return</span> x <span class="delim">%</span> <span class="literal int">2</span> <span class="delim">==</span> <span class="literal int">1</span><span class="delim">; } };</span>

<span class="keyword">auto</span> <span class="keyword">const</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">4</span><span class="delim">,</span> <span class="literal int">5</span><span class="delim">,</span> <span class="literal int">6</span><span class="delim">,</span> <span class="literal int">7</span><span class="delim">,</span> <span class="literal int">8</span><span class="delim">,</span> <span class="literal int">9</span><span class="delim">,</span> <span class="literal int">10</span> <span class="delim">};</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> boost<span class="delim">::</span>adaptors<span class="delim">;</span>

cout <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>r <span class="delim">|</span> reversed <span class="delim">|</span> filtered<span class="delim">(</span>is_odd<span class="delim">{}),</span> <span class="literal string">", "</span><span class="delim">);</span>

<span class="line comment">// output: "9, 7, 5, 3, 1"</span></code></pre>
<p>
  Input, however, is more complicated, partly because you need to do the filtering while the values are being read in, and partly because there are multiple ways you can add values to a range.
  For that reason, several input functions are included in the proposal, covering the most common ways values are added to a range:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> a <span class="delim">=</span> array<span class="delim">&lt;</span><span class="keyword">double</span><span class="delim">,</span> <span class="literal int">10</span><span class="delim">&gt;{};</span>
in <span class="delim">&gt;&gt;</span> overwrite<span class="delim">(</span>a<span class="delim">);</span> <span class="line comment">// reads 10 doubles into a</span>

<span class="keyword">auto</span> v <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{};</span>
in <span class="delim">&gt;&gt;</span> back_insert<span class="delim">(</span>v<span class="delim">);</span> <span class="line comment">// reads ints until a read failure, adding them via v.push_back()</span>
in <span class="delim">&gt;&gt;</span> back_insert_n<span class="delim">(</span>v<span class="delim">,</span> <span class="literal int">5</span><span class="delim">);</span> <span class="line comment">// reads ints until 5 are read or there is a read failure,</span>
                           <span class="line comment">// whichever comes first, adding them via v.push_back()</span>

<span class="keyword">auto</span> l <span class="delim">=</span> list<span class="delim">&lt;</span>complex<span class="delim">&lt;</span><span class="keyword">float</span><span class="delim">&gt;&gt;{};</span>
in <span class="delim">&gt;&gt;</span> front_insert<span class="delim">(</span>l<span class="delim">);</span> <span class="line comment">// similar to back_insert(), except this uses l.push_front()</span>
in <span class="delim">&gt;&gt;</span> front_insert_n<span class="delim">(</span>l<span class="delim">,</span> <span class="literal int">5</span><span class="delim">);</span>

<span class="keyword">auto</span> s <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span> <span class="literal int">0</span><span class="delim">,</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">4</span><span class="delim">,</span> <span class="literal int">5</span> <span class="delim">};</span>
in <span class="delim">&gt;&gt;</span> insert<span class="delim">(</span>s<span class="delim">,</span> next<span class="delim">(</span>begin<span class="delim">(</span>s<span class="delim">),</span> <span class="literal int">3</span><span class="delim">));</span> <span class="line comment">// reads ints until a read failure, adding them</span>
                                    <span class="line comment">// via s.insert() sequentially starting after the 2</span>
in <span class="delim">&gt;&gt;</span> insert_n<span class="delim">(</span>s<span class="delim">,</span> next<span class="delim">(</span>begin<span class="delim">(</span>s<span class="delim">),</span> <span class="literal int">3</span><span class="delim">),</span> <span class="literal int">5</span><span class="delim">);</span></code></pre>
<p>
  There is also a generalized input function that you can customize using a traits type.
  You define a class with two functions – <code class="lang-cpp">prepare<span class="delim">()</span></code> and <code class="lang-cpp">read<span class="delim">()</span></code> – then pass an instance of that class to the generalized input function.
  Using that, you can customize any kind of input operation you like.
  For example, reading only odd numbers and inserting them into a range in order:
</p>
<pre><code class="lang-cpp"><span class="keyword">struct</span> insert_only_if_odd
<span class="delim">{</span>
  <span class="keyword">using</span> iterator_type = vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;::</span>iterator<span class="delim">;</span>
  
  <span class="keyword">auto</span> prepare<span class="delim">(</span>vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;&amp;</span> r<span class="delim">,</span> iterator_type <span class="block comment">/* not used here */</span><span class="delim">)</span>
  <span class="delim">{</span>
    <span class="keyword">return</span> make_tuple<span class="delim">(</span><span class="keyword">true</span><span class="delim">,</span> end<span class="delim">(</span>r<span class="delim">));</span>
  <span class="delim">}</span>
  
  <span class="keyword">auto</span> read<span class="delim">(</span>istream<span class="delim">&amp;</span> in<span class="delim">,</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;&amp;</span> r<span class="delim">,</span> iterator_type <span class="block comment">/* not used here */</span><span class="delim">)</span>
  <span class="delim">{</span>
    <span class="keyword">auto</span> v <span class="delim">=</span> <span class="keyword">int</span><span class="delim">{};</span>
    
    <span class="keyword">auto</span> store_ok <span class="delim">=</span> <span class="keyword">false</span><span class="delim">;</span>
    <span class="keyword">auto</span> read_ok <span class="delim">=</span> <span class="keyword">bool</span><span class="delim">(</span>in <span class="delim">&gt;&gt;</span> v<span class="delim">);</span>
    
    <span class="keyword">if</span> <span class="delim">(</span>read_ok <span class="delim">&amp;&amp; (</span>v <span class="delim">%</span> <span class="literal_int">2</span><span class="delim">))</span>
    <span class="delim">{</span>
      r<span class="delim">.</span>insert<span class="delim">(</span>upper_bound<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> v<span class="delim">),</span> v<span class="delim">);</span>
      store_ok <span class="delim">=</span> <span class="keyword">true</span><span class="delim">;</span>
    <span class="delim">}</span>
    
    <span class="keyword">return</span> make_tuple<span class="delim">(</span><span class="keyword">bool</span><span class="delim">(</span>in<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> read_ok<span class="delim">,</span> store_ok<span class="delim">);</span>
  <span class="delim">}</span>
<span class="delim">};</span>

<span class="keyword">auto</span> iss <span class="delim">=</span> istringstream<span class="delim">{</span><span class="string literal">"6 2 8 3 1 8 5 3 0 7 1 7 9"</span><span class="delim">};</span>

<span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{};</span>

iss <span class="delim">&gt;&gt;</span> input<span class="delim">(</span>r<span class="delim">,</span> insert_only_if_odd<span class="delim">{});</span>

<span class="line comment">// r = { 1, 1, 3, 3, 5, 7, 7, 9 }</span></code></pre>

<section id="rangeio-formatting">
<h1>Formatting</h1>

<p>
  Perhaps the biggest improvement of range <abbr>I/O</abbr> functions over stream iterators and algorithms is awareness of stream formatting.
</p>
<p>
  The philosophy of formatting in range <abbr>I/O</abbr> functions can be summed up as:
</p>
<ul>
  <li>
    Whatever formatting is applied to the <em>first</em> value read/written in a range <abbr>I/O</abbr> operation gets applied to <em>every</em> value in that operation.
  </li>
  <li>
    The stream formatting state after a range <abbr>I/O</abbr> operation must be the same whether zero, one, or many values were read/written in that operation.
  </li>
</ul>
<p>
  The first point allows you to set up the stream’s formatting state the way you desire, and have every element of the range be formatted according to that state:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> <span class="keyword">const</span> r <span class="delim">=</span> array<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">,</span> <span class="literal int">5</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">5</span> <span class="delim">};</span>
out <span class="delim">&lt;&lt;</span> <span class="literal string">"{ "</span> <span class="delim">&lt;&lt;</span> hex <span class="delim">&lt;&lt;</span> showbase <span class="delim">&lt;&lt;</span> setfill<span class="delim">(</span><span class="literal char">'-'</span><span class="delim">)</span> <span class="delim">&lt;&lt;</span> setw<span class="delim">(</span><span class="literal int">5</span><span class="delim">)</span> <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>r<span class="delim">,</span> <span class="literal string">", "</span><span class="delim">) &lt;&lt;</span> <span class="literal string">" }"</span><span class="delim">;</span>
<span class="line comment">// output: "{ --0x1, --0x1, --0x2, --0x3, --0x5 }"</span></code></pre>
<p>
  The second point means that you don’t need to worry about how many elements are in the range – if any.
  You will have a consistent, predictable formatting state after the operation (as you can see above – the closing brace is added quite naturally, and would be printed as you would expect even if the range was empty).
</p>
<p>
  Note that in the case of delimited output, the formatting only applies to the actual range elements.
  The formatting applied to the delimiter is determined by whatever state the stream would be left in after writing a single value of the range’s type.
</p>
<p>
  The formatting rules also apply to input:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> iss <span class="delim">=</span> istringstream<span class="delim">{</span><span class="literal string">"abcdefghi"</span><span class="delim">};</span>
<span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{};</span>
<span class="keyword">auto</span> s <span class="delim">=</span> string<span class="delim">{};</span>
iss <span class="delim">&gt;&gt;</span> setw<span class="delim">(</span><span class="literal int">2</span><span class="delim">)</span> <span class="delim">&gt;&gt;</span> back_insert<span class="delim">(</span>r<span class="delim">);</span>
<span class="line comment">// r = { "ab", "cd", "ef" }</span>
<span class="line comment">// s = "ghi"</span></code></pre>
</section>
<section id="rangeio-error_handling">
<h1>Error handling</h1>

<p>
  The range <abbr>I/O</abbr> functions also give you much more information about exactly what went down in an <abbr>I/O</abbr> operation – including whether any errors occurred.
</p>
<p>
  To get this information, you have to capture the range <abbr>I/O</abbr> operation object returned by the range <abbr>I/O</abbr> function.
  You use this object in an <abbr>I/O</abbr> expression as usual, but after the operation the range <abbr>I/O</abbr> object can be queried.
</p>
<p>
  For example, the <code class="lang-cpp">next</code> member holds the iterator to the next element in the range where a value would be written (equivalent to the return value you would get if you used <code class="lang-cpp">std<span class="delim">::</span>copy<span class="delim">()</span></code> with istream iterators):
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> array<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">,</span> <span class="literal int">10</span><span class="delim">&gt;{};</span>

<span class="keyword">auto</span> p <span class="delim">=</span> overwrite<span class="delim">(</span>r<span class="delim">);</span>
in <span class="delim">&gt;&gt;</span> p<span class="delim">;</span>

<span class="keyword">if</span> <span class="delim">(</span>p<span class="delim">.</span>next <span class="delim">!=</span> end<span class="delim">(</span>r<span class="delim">))</span>
<span class="delim">{</span>
  cerr <span class="delim">&lt;&lt;</span> <span class="literal string">"An error occurred during input.\n"</span><span class="delim">;</span>
  cerr <span class="delim">&lt;&lt;</span> <span class="literal string">"Number of successfully read values = "</span> <span class="delim">&lt;&lt;</span> distance<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> p<span class="delim">.</span>next<span class="delim">) &lt;&lt;</span> <span class="literal string">" of "</span> <span class="delim">&lt;&lt;</span> r<span class="delim">.</span>size<span class="delim">() &lt;&lt;</span> <span class="literal char">'\n'</span><span class="delim">;</span>
  cerr <span class="delim">&lt;&lt;</span> <span class="literal string">"Successfully read = { "</span> <span class="delim">&lt;&lt;</span> write_all<span class="delim">(</span>boost<span class="delim">::</span>make_iterator_range<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> p<span class="delim">.</span>next<span class="delim">),</span> <span class="literal string">", "</span><span class="delim">) &lt;&lt;</span> <span class="literal string">" }\n"</span><span class="delim">;</span>
<span class="delim">}</span></code></pre>
<p>
  (The previous example uses <a href="http://www.boost.org/doc/libs/1_56_0/libs/range/doc/html/range/reference/utilities/iterator_range.html"><code class="lang-cpp">iterator_range</code></a> from <a href="http://www.boost.org/doc/libs/1_56_0/libs/range/doc/html/index.html">Boost.Range</a>.)
</p>
<p>
  Range input operation objects also have two members that count the number of elements read from the stream, and the number actually stored in the range.
  For the standard input operation objects, those counts will always be the same, but if you use a filtering input operation they may be different:
</p>
<pre><code class="lang-cpp"><span class="keyword">struct</span> insert_only_if_odd
<span class="delim">{</span>
  <span class="keyword">using</span> iterator_type = vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;::</span>iterator<span class="delim">;</span>
  
  <span class="keyword">auto</span> prepare<span class="delim">(</span>vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;&amp;</span> r<span class="delim">,</span> iterator_type <span class="block comment">/* not used here */</span><span class="delim">)</span>
  <span class="delim">{</span>
    <span class="keyword">return</span> make_tuple<span class="delim">(</span><span class="keyword">true</span><span class="delim">,</span> end<span class="delim">(</span>r<span class="delim">));</span>
  <span class="delim">}</span>
  
  <span class="keyword">auto</span> read<span class="delim">(</span>istream<span class="delim">&amp;</span> in<span class="delim">,</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;&amp;</span> r<span class="delim">,</span> iterator_type <span class="block comment">/* not used here */</span><span class="delim">)</span>
  <span class="delim">{</span>
    <span class="keyword">auto</span> v <span class="delim">=</span> <span class="keyword">int</span><span class="delim">{};</span>
    
    <span class="keyword">auto</span> store_ok <span class="delim">=</span> <span class="keyword">false</span><span class="delim">;</span>
    <span class="keyword">auto</span> read_ok <span class="delim">=</span> <span class="keyword">bool</span><span class="delim">(</span>in <span class="delim">&gt;&gt;</span> v<span class="delim">);</span>
    
    <span class="keyword">if</span> <span class="delim">(</span>read_ok <span class="delim">&amp;&amp; (</span>v <span class="delim">%</span> <span class="literal_int">2</span><span class="delim">))</span>
    <span class="delim">{</span>
      r<span class="delim">.</span>insert<span class="delim">(</span>upper_bound<span class="delim">(</span>begin<span class="delim">(</span>r<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> v<span class="delim">),</span> v<span class="delim">);</span>
      store_ok <span class="delim">=</span> <span class="keyword">true</span><span class="delim">;</span>
    <span class="delim">}</span>
    
    <span class="keyword">return</span> make_tuple<span class="delim">(</span><span class="keyword">bool</span><span class="delim">(</span>in<span class="delim">),</span> end<span class="delim">(</span>r<span class="delim">),</span> read_ok<span class="delim">,</span> store_ok<span class="delim">);</span>
  <span class="delim">}</span>
<span class="delim">};</span>

<span class="keyword">auto</span> iss <span class="delim">=</span> istringstream<span class="delim">{</span><span class="string literal">"6 2 8 3 1 8 5 3 0 7 1 7 9"</span><span class="delim">};</span>

<span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{};</span>

<span class="keyword">auto</span> p <span class="delim">=</span> input<span class="delim">(</span>r<span class="delim">,</span> insert_only_if_odd<span class="delim">{});</span>
iss <span class="delim">&gt;&gt;</span> p<span class="delim">;</span>

<span class="line comment">// r = { 1, 1, 3, 3, 5, 7, 7, 9 }</span>
<span class="line comment">// p.next = end(r)</span>
<span class="line comment">// p.count = 13</span>
<span class="line comment">// p.stored = 8</span></code></pre>
<p>
  As you can see, 13 values were read from the stream, but only 8 were placed in the range.
</p>
<p>
  Output operation objects also have the <code class="lang-cpp">next</code> member – which is an iterator to the next item in the range that would be written – and a <code class="lang-cpp">count</code> member that counts the number of values that were written in the last output operation:
</p>
<pre><code class="lang-cpp"><span class="keyword">auto</span> r <span class="delim">=</span> vector<span class="delim">&lt;</span><span class="keyword">int</span><span class="delim">&gt;{</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">1</span><span class="delim">,</span> <span class="literal int">2</span><span class="delim">,</span> <span class="literal int">3</span><span class="delim">,</span> <span class="literal int">5</span> <span class="delim">};</span>
<span class="keyword">auto</span> p <span class="delim">=</span> write_all<span class="delim">(</span>r<span class="delim">,</span> <span class="literal string">", "</span><span class="delim">);</span>
out <span class="delim">&lt;&lt;</span> p<span class="delim">;</span>
<span class="line comment">// output: "1, 1, 2, 3, 5"</span>
<span class="line comment">// p.next = end(r)</span>
<span class="line comment">// p.count = 5</span></code></pre>
</section>
</section>
<section id="reference">
<h1>Reference</h1>

<section id="reference-input">
<h1>Input</h1>

<table class="function-reference">
  <thead>
    <tr>
      <th>Function</th>
      <th>Arguments</th>
      <th>Effects</th>
      <th>Supports</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">overwrite<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Overwrites each element in <var>r</var> with successive values.</li>
          <li>Stops when <var>r</var> is completely overwritten, or after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li>C arrays of known bound</li>
          <li><code class="lang-cpp">std<span class="delim">::</span>array</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>forward_list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>valarray</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">back_insert<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the end of <var>r</var> using <code class="lang-cpp">push_back<span class="delim">()</span></code>.</li>
          <li>Stops after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">back_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the end of <var>r</var> using <code class="lang-cpp">push_back<span class="delim">()</span></code>.</li>
          <li>Stops after <var>n</var> values are read, or after a read failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">front_insert<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the start of <var>r</var> using <code class="lang-cpp">push_front<span class="delim">()</span></code>.</li>
          <li>Stops after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>forward_list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">front_insert_n<span class="delim">(</span>r<span class="delim">,</span> n<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to the start of <var>r</var> using <code class="lang-cpp">push_front<span class="delim">()</span></code>.</li>
          <li>Stops after <var>n</var> values are read, or after a read failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">insert<span class="delim">(</span>r<span class="delim">,</span> p<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>p</var></dt>
          <dd>Iterator for <var>r</var></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to <var>r</var> before the element referenced by <var>p</var> using <code class="lang-cpp">insert<span class="delim">()</span></code>.</li>
          <li>Stops after a read failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">insert_n<span class="delim">(</span>r<span class="delim">,</span> p<span class="delim">,</span> n<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>p</var></dt>
          <dd>Iterator for <var>r</var></dd>
          <dt><var>n</var></dt>
          <dd><code class="lang-cpp">size_t</code></dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Adds successive values to <var>r</var> before the element referenced by <var>p</var> using <code class="lang-cpp">insert<span class="delim">()</span></code>.</li>
          <li>Stops after <var>n</var> values are read, or after a read failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">input<span class="delim">(</span>r<span class="delim">,</span> b<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd>Non-<code class="lang-cpp"><span class="keyword">const</span></code> range lvalue</dd>
          <dt><var>d</var></dt>
          <dd>Instance of an object that describes an input behaviour</dd>
        </dl>
      </td>
      <td>
        Depends on behaviour.
      </td>
      <td>
        Depends on behaviour.
      </td>
    </tr>
  </tbody>
</table>

<p>
  All range input functions return a range input object that references the range.
  The object cannot be default-constructed (it must be constructed by a range input function), and it satisfies the following concepts:
</p>
<ul>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/Destructible">Destructible</a></code></li>
</ul>
<p>
  The range input object has the following members:
</p>
<table class="proxy-reference">
  <thead>
    <tr>
      <th>Member</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">next</code></td>
      <td><code class="lang-cpp"><i>Iterator</i></code></td>
      <td>
        An iterator to the range that is being read into, pointing to the next location that would be read into if this input operation were continued.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">count</code></td>
      <td><code class="lang-cpp">size_t</code></td>
      <td>
        The number of values that were successfully read from the stream in the last input operation.
        Initially zero.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">stored</code></td>
      <td><code class="lang-cpp">size_t</code></td>
      <td>
        The number of values that were added to the range in the last input operation.
        Initially zero.
      </td>
    </tr>
  </tbody>
</table>
</section>

<section id="reference-output">
<h1>Output</h1>

<table class="function-reference">
  <thead>
    <tr>
      <th>Function</th>
      <th>Arguments</th>
      <th>Effects</th>
      <th>Supports</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">write_all<span class="delim">(</span>r<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd><code class="lang-cpp"><span class="keyword">const</span></code> lvalue reference or non-<code class="lang-cpp"><span class="keyword">const</span></code> rvalue reference to a range.</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Writes each element in <var>r</var> to the output stream successively.</li>
          <li>Stops when <var>r</var> is completely written, or after a write failure.</li>
        </ul>
      </td>
      <td>
        <ul class="comma">
          <li>C arrays of known bound</li>
          <li><code class="lang-cpp">std<span class="delim">::</span>array</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>vector</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>deque</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>forward_list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>list</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>basic_string</code></li>
          <li><code class="lang-cpp">std<span class="delim">::</span>valarray</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">write_all<span class="delim">(</span>r<span class="delim">,</span> d<span class="delim">)</span></code></td>
      <td>
        <dl>
          <dt><var>r</var></dt>
          <dd><code class="lang-cpp"><span class="keyword">const</span></code> lvalue reference or non-<code class="lang-cpp"><span class="keyword">const</span></code> rvalue reference to a range.</dd>
          <dt><var>d</var></dt>
          <dd>An instance of a type that can be written to an output stream.</dd>
        </dl>
      </td>
      <td>
        <ul>
          <li>Writes each element in <var>r</var> to the output stream successively.</li>
          <li>The delimiter <var>d</var> is written after each value, except the last.</li>
          <li>Stops when <var>r</var> is completely written, or after a write failure.</li>
        </ul>
      </td>
      <td>
        Same as above.
      </td>
    </tr>
  </tbody>
</table>

<p>
  All range output functions return a range output object that references the range, or – in the case of rvalues – takes ownership of the range (by moving).
  The object cannot be default-constructed (it must be constructed by a range output function), and it satisfies the following concepts:
</p>
<ul>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</a></code></li>
  <li><code><a href="http://en.cppreference.com/w/cpp/concept/Destructible">Destructible</a></code></li>
</ul>
<p>
  The range output object has the following members:
</p>
<table class="proxy-reference">
  <thead>
    <tr>
      <th>Member</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="lang-cpp">next</code></td>
      <td><code class="lang-cpp"><i>Iterator</i></code></td>
      <td>
        An iterator to the range that is being read from, pointing to the next location that would be read from if this output operation were continued.
      </td>
    </tr>
    <tr>
      <td><code class="lang-cpp">count</code></td>
      <td><code class="lang-cpp">size_t</code></td>
      <td>
        The number of values that were successfully written to the stream in the last output operation.
        Initially zero.
      </td>
    </tr>
  </tbody>
</table>
</section>
</section>
</main>
<footer>
  <dl id="version-info">
    <dt>Version</dt>
    <dd>2.0.0</dd>
    <dt>Date</dt>
    <dd><time>2014-09-17</time></dd>
  </dl>
  <p>
    For the latest version of the proposal, see <a href="https://github.com/DarkerStar/cpp-range-streaming">https://github.com/DarkerStar/cpp-range-streaming</a>.
  </p>
  <p id="copyright">
    © Copyright 2014 Mark A. Gibbs. All rights reserved.
  </p>
</footer>
</body>
</html>